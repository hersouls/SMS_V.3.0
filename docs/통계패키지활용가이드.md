# SMS V.3.0 통계 패키지 활용 가이드

## 📊 개요

SMS V.3.0에서 사용 가능한 다양한 통계 패키지들의 활용 방법과 예제를 제공합니다.

## 🎯 설치된 패키지 목록

### 차트 및 시각화 라이브러리

#### 1. Recharts (기본)
```bash
npm install recharts
```
- **용도**: React 기반 차트 라이브러리
- **특징**: 간단하고 직관적인 API
- **적합한 차트**: 선형, 막대, 원형, 영역 차트

#### 2. D3.js (고급)
```bash
npm install d3 @types/d3
```
- **용도**: 데이터 기반 문서 시각화
- **특징**: 완전한 커스터마이징 가능
- **적합한 차트**: 히트맵, 네트워크, 복잡한 시각화

#### 3. Victory (고급)
```bash
npm install victory @types/victory
```
- **용도**: React 데이터 시각화
- **특징**: 애니메이션과 인터랙션
- **적합한 차트**: 동적 차트, 게임화 요소

#### 4. Nivo (고급)
```bash
npm install @nivo/core @nivo/line @nivo/bar @nivo/pie @nivo/heatmap
```
- **용도**: React 기반 고급 차트
- **특징**: 반응형 디자인, 접근성
- **적합한 차트**: 모든 종류의 차트

### 데이터 처리 라이브러리

#### 1. Lodash
```bash
npm install lodash @types/lodash
```
- **용도**: 유틸리티 함수 모음
- **특징**: 배열, 객체, 문자열 처리
- **활용**: 데이터 변환, 필터링, 그룹핑

#### 2. Simple Statistics
```bash
npm install simple-statistics
```
- **용도**: 통계 계산 라이브러리
- **특징**: 평균, 표준편차, 상관관계 등
- **활용**: 데이터 분석, 인사이트 생성

#### 3. XLSX
```bash
npm install xlsx
```
- **용도**: Excel 파일 처리
- **특징**: 읽기/쓰기 지원
- **활용**: 데이터 내보내기/가져오기

## 📈 패키지별 활용 예제

### 1. Recharts 활용

#### 기본 선형 차트
```typescript
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend } from 'recharts';

const data = [
  { month: '2024-01', amount: 50000 },
  { month: '2024-02', amount: 65000 },
  { month: '2024-03', amount: 45000 },
];

function MonthlyTrendChart() {
  return (
    <LineChart width={600} height={300} data={data}>
      <CartesianGrid strokeDasharray="3 3" />
      <XAxis dataKey="month" />
      <YAxis />
      <Tooltip />
      <Legend />
      <Line type="monotone" dataKey="amount" stroke="#8884d8" />
    </LineChart>
  );
}
```

#### 원형 차트
```typescript
import { PieChart, Pie, Cell, Tooltip } from 'recharts';

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042'];

function CategoryPieChart({ data }) {
  return (
    <PieChart width={400} height={400}>
      <Pie
        data={data}
        cx={200}
        cy={200}
        labelLine={false}
        label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
        outerRadius={80}
        fill="#8884d8"
        dataKey="value"
      >
        {data.map((entry, index) => (
          <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
        ))}
      </Pie>
      <Tooltip />
    </PieChart>
  );
}
```

### 2. D3.js 활용

#### 히트맵 생성
```typescript
import * as d3 from 'd3';

function createHeatmap(data, containerId) {
  const margin = { top: 20, right: 20, bottom: 30, left: 40 };
  const width = 600 - margin.left - margin.right;
  const height = 400 - margin.top - margin.bottom;

  const svg = d3.select(`#${containerId}`)
    .append('svg')
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
    .append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`);

  const xScale = d3.scaleBand()
    .domain(data.map(d => d.month))
    .range([0, width]);

  const yScale = d3.scaleLinear()
    .domain([0, d3.max(data, d => d.value)])
    .range([height, 0]);

  const colorScale = d3.scaleSequential()
    .domain([0, d3.max(data, d => d.value)])
    .interpolator(d3.interpolateBlues);

  svg.selectAll('rect')
    .data(data)
    .enter()
    .append('rect')
    .attr('x', d => xScale(d.month))
    .attr('y', d => yScale(d.value))
    .attr('width', xScale.bandwidth())
    .attr('height', d => height - yScale(d.value))
    .attr('fill', d => colorScale(d.value));
}
```

### 3. Victory 활용

#### 애니메이션 차트
```typescript
import { VictoryChart, VictoryLine, VictoryTheme, VictoryAxis } from 'victory';

function AnimatedLineChart({ data }) {
  return (
    <VictoryChart theme={VictoryTheme.material}>
      <VictoryAxis
        tickFormat={(t) => t}
        style={{
          tickLabels: { fontSize: 8, angle: -45 }
        }}
      />
      <VictoryAxis
        dependentAxis
        tickFormat={(t) => `${t}원`}
      />
      <VictoryLine
        data={data}
        x="month"
        y="amount"
        style={{
          data: { stroke: "#c43a31" },
          parent: { border: "1px solid #ccc" }
        }}
        animate={{
          duration: 2000,
          onLoad: { duration: 1000 }
        }}
      />
    </VictoryChart>
  );
}
```

### 4. Nivo 활용

#### 반응형 차트
```typescript
import { ResponsiveLine } from '@nivo/line';

function ResponsiveLineChart({ data }) {
  return (
    <ResponsiveLine
      data={[
        {
          id: '지출',
          data: data.map(item => ({
            x: item.month,
            y: item.amount
          }))
        }
      ]}
      margin={{ top: 50, right: 110, bottom: 50, left: 60 }}
      xScale={{ type: 'point' }}
      yScale={{ type: 'linear', min: 'auto', max: 'auto' }}
      axisTop={null}
      axisRight={null}
      axisBottom={{
        tickSize: 5,
        tickPadding: 5,
        tickRotation: 0,
        legend: '월',
        legendOffset: 36,
        legendPosition: 'middle'
      }}
      axisLeft={{
        tickSize: 5,
        tickPadding: 5,
        tickRotation: 0,
        legend: '지출 (원)',
        legendOffset: -40,
        legendPosition: 'middle'
      }}
      pointSize={10}
      pointColor={{ theme: 'background' }}
      pointBorderWidth={2}
      pointBorderColor={{ from: 'serieColor' }}
      pointLabelYOffset={-12}
      useMesh={true}
      legends={[
        {
          anchor: 'bottom-right',
          direction: 'column',
          justify: false,
          translateX: 100,
          translateY: 0,
          itemsSpacing: 0,
          itemDirection: 'left-to-right',
          itemWidth: 80,
          itemHeight: 20,
          itemsSymbolSize: 12,
          itemTextColor: '#999',
          symbolSize: 12,
          symbolShape: 'circle'
        }
      ]}
    />
  );
}
```

## 🔧 데이터 처리 활용

### 1. Lodash 활용

#### 데이터 그룹핑
```typescript
import _ from 'lodash';

// 카테고리별 그룹핑
const groupedByCategory = _.groupBy(subscriptions, 'category');

// 월별 지출 합계
const monthlyTotals = _.mapValues(
  _.groupBy(subscriptions, 'month'),
  items => _.sumBy(items, 'amount')
);

// 상위 카테고리 찾기
const topCategories = _.orderBy(
  Object.entries(groupedByCategory).map(([category, items]) => ({
    category,
    total: _.sumBy(items, 'amount'),
    count: items.length
  })),
  'total',
  'desc'
).slice(0, 5);
```

### 2. Simple Statistics 활용

#### 통계 분석
```typescript
import ss from 'simple-statistics';

// 기본 통계
const amounts = subscriptions.map(s => s.amount);
const mean = ss.mean(amounts);
const median = ss.median(amounts);
const standardDeviation = ss.standardDeviation(amounts);

// 성장률 계산
const growthRates = [];
for (let i = 1; i < monthlyData.length; i++) {
  const growth = ((monthlyData[i].amount - monthlyData[i-1].amount) / monthlyData[i-1].amount) * 100;
  growthRates.push(growth);
}

const averageGrowth = ss.mean(growthRates);
const growthTrend = ss.linearRegression(growthRates.map((rate, index) => [index, rate]));
```

### 3. XLSX 활용

#### Excel 내보내기
```typescript
import * as XLSX from 'xlsx';

function exportToExcel(data, filename) {
  // 워크북 생성
  const wb = XLSX.utils.book_new();
  
  // 데이터를 워크시트로 변환
  const ws = XLSX.utils.json_to_sheet(data);
  
  // 워크시트를 워크북에 추가
  XLSX.utils.book_append_sheet(wb, ws, 'Statistics');
  
  // 파일 다운로드
  XLSX.writeFile(wb, `${filename}.xlsx`);
}

// 사용 예제
const statisticsData = [
  { category: '엔터테인먼트', amount: 50000, count: 3 },
  { category: '음악', amount: 30000, count: 2 },
  { category: '개발', amount: 80000, count: 4 }
];

exportToExcel(statisticsData, 'subscription-statistics');
```

## 🎨 고급 시각화 예제

### 1. 대시보드 컴포넌트
```typescript
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs';

function StatisticsDashboard() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadStatistics();
  }, []);

  const loadStatistics = async () => {
    try {
      setLoading(true);
      // 데이터 로딩 로직
      const statistics = await fetchStatistics();
      setData(statistics);
    } catch (error) {
      console.error('통계 로딩 실패:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return <div>로딩 중...</div>;
  }

  return (
    <div className="p-6">
      <h1 className="text-3xl font-bold mb-6">통계 대시보드</h1>
      
      <Tabs defaultValue="overview" className="space-y-4">
        <TabsList>
          <TabsTrigger value="overview">개요</TabsTrigger>
          <TabsTrigger value="charts">차트</TabsTrigger>
          <TabsTrigger value="analysis">분석</TabsTrigger>
        </TabsList>
        
        <TabsContent value="overview">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <Card>
              <CardHeader>
                <CardTitle>총 지출</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-2xl font-bold">
                  {data?.totalSpending?.toLocaleString()}원
                </p>
              </CardContent>
            </Card>
            {/* 추가 카드들 */}
          </div>
        </TabsContent>
        
        <TabsContent value="charts">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <Card>
              <CardHeader>
                <CardTitle>월별 트렌드</CardTitle>
              </CardHeader>
              <CardContent>
                <MonthlyTrendChart data={data?.monthlyTrends} />
              </CardContent>
            </Card>
            
            <Card>
              <CardHeader>
                <CardTitle>카테고리 분포</CardTitle>
              </CardHeader>
              <CardContent>
                <CategoryPieChart data={data?.categoryStats} />
              </CardContent>
            </Card>
          </div>
        </TabsContent>
        
        <TabsContent value="analysis">
          <div className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle>인사이트</CardTitle>
              </CardHeader>
              <CardContent>
                <ul className="space-y-2">
                  {data?.insights?.map((insight, index) => (
                    <li key={index} className="flex items-center gap-2">
                      <span className="w-2 h-2 bg-blue-500 rounded-full"></span>
                      {insight}
                    </li>
                  ))}
                </ul>
              </CardContent>
            </Card>
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
}
```

### 2. 실시간 업데이트
```typescript
import { useEffect, useState } from 'react';

function RealTimeStatistics() {
  const [data, setData] = useState(null);
  const [lastUpdate, setLastUpdate] = useState(null);

  useEffect(() => {
    // 실시간 구독 설정
    const unsubscribe = subscribeToStatistics(userId, (newData) => {
      setData(newData);
      setLastUpdate(new Date());
    });

    return () => unsubscribe();
  }, [userId]);

  return (
    <div>
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-xl font-semibold">실시간 통계</h2>
        {lastUpdate && (
          <span className="text-sm text-gray-500">
            마지막 업데이트: {lastUpdate.toLocaleTimeString()}
          </span>
        )}
      </div>
      
      {/* 실시간 차트들 */}
    </div>
  );
}
```

## 🚀 성능 최적화

### 1. 차트 최적화
```typescript
// 메모이제이션을 통한 성능 최적화
import { useMemo } from 'react';

function OptimizedChart({ data }) {
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      formattedAmount: item.amount.toLocaleString()
    }));
  }, [data]);

  return <LineChart data={processedData} />;
}
```

### 2. 데이터 캐싱
```typescript
const statisticsCache = new Map();

async function getCachedStatistics(key, fetchFunction) {
  if (statisticsCache.has(key)) {
    const cached = statisticsCache.get(key);
    if (Date.now() - cached.timestamp < 5 * 60 * 1000) { // 5분 캐시
      return cached.data;
    }
  }
  
  const data = await fetchFunction();
  statisticsCache.set(key, {
    data,
    timestamp: Date.now()
  });
  
  return data;
}
```

## 📊 패키지 선택 가이드

### 용도별 추천

#### 1. 기본 차트 (Recharts)
- **적합한 경우**: 빠른 개발, 간단한 차트
- **장점**: 쉬운 학습 곡선, React 친화적
- **단점**: 복잡한 커스터마이징 제한

#### 2. 고급 시각화 (D3.js)
- **적합한 경우**: 복잡한 시각화, 완전한 제어
- **장점**: 무한한 커스터마이징, 강력한 기능
- **단점**: 높은 학습 곡선, 복잡한 코드

#### 3. 애니메이션 차트 (Victory)
- **적합한 경우**: 동적 차트, 게임화 요소
- **장점**: 부드러운 애니메이션, 인터랙션
- **단점**: 번들 크기, 복잡한 설정

#### 4. 반응형 차트 (Nivo)
- **적합한 경우**: 모바일 최적화, 접근성
- **장점**: 자동 반응형, 접근성 지원
- **단점**: 제한된 커스터마이징

## 🔧 설정 및 환경

### 1. TypeScript 설정
```json
{
  "compilerOptions": {
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  }
}
```

### 2. 번들 최적화
```javascript
// vite.config.js
export default {
  optimizeDeps: {
    include: ['d3', 'lodash', 'simple-statistics']
  }
}
```

## 📝 모범 사례

### 1. 컴포넌트 구조
```typescript
// components/charts/
├── ChartContainer.tsx      // 차트 래퍼
├── RechartsCharts.tsx     // Recharts 차트들
├── D3Charts.tsx          // D3 차트들
├── VictoryCharts.tsx     // Victory 차트들
└── NivoCharts.tsx        // Nivo 차트들
```

### 2. 데이터 처리
```typescript
// utils/chartData.ts
export function processChartData(rawData) {
  // 데이터 전처리 로직
}

export function createChartConfig(type) {
  // 차트 타입별 설정
}
```

### 3. 에러 처리
```typescript
function SafeChart({ data, fallback }) {
  if (!data || data.length === 0) {
    return fallback || <div>데이터가 없습니다.</div>;
  }
  
  try {
    return <Chart data={data} />;
  } catch (error) {
    console.error('차트 렌더링 실패:', error);
    return <div>차트를 불러올 수 없습니다.</div>;
  }
}
```

---

*이 가이드는 SMS V.3.0의 통계 패키지 활용을 위한 완전한 참조 자료입니다.* 